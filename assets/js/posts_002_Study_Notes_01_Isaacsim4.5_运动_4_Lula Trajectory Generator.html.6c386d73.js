"use strict";(self.webpackChunkhi_hub=self.webpackChunkhi_hub||[]).push([[935],{6262(e,t){t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,r]of t)a[e]=r;return a}},7364(e,t,a){a.r(t),a.d(t,{comp:()=>i,data:()=>n});var r=a(641);const s={},i=(0,a(6262).A)(s,[["render",function(e,t){return(0,r.uX)(),(0,r.CE)("div",null,[...t[0]||(t[0]=[(0,r.Fv)('<h1 id="lula-trajectory-generator-架构深度学习笔记" tabindex="-1"><a class="header-anchor" href="#lula-trajectory-generator-架构深度学习笔记"><span>Lula Trajectory Generator 架构深度学习笔记</span></a></h1><blockquote><p><strong>学习背景</strong>：深入理解 NVIDIA Isaac Sim 中 Lula 轨迹生成系统。该系统通过连接离散的航点，生成平滑、符合动力学约束（速度、加速度、Jerk）的运动指令。</p></blockquote><hr><h2 id="一、-架构总览与初始化逻辑" tabindex="-1"><a class="header-anchor" href="#一、-架构总览与初始化逻辑"><span>一、 架构总览与初始化逻辑</span></a></h2><h3 id="_1-1-核心分工" tabindex="-1"><a class="header-anchor" href="#_1-1-核心分工"><span>1.1 核心分工</span></a></h3><p>Lula 轨迹生成系统由两个主要脚本驱动，职责明确：</p><ul><li><strong><code>scenario.py</code> (算法逻辑层)</strong>：负责加载机器人配置、调用 Lula 库计算数学轨迹、将轨迹离散化为动作序列。</li><li><strong><code>ui_builder.py</code> (交互表现层)</strong>：负责渲染 Isaac Sim 右侧面板的按钮，控制仿真时间线的播放与暂停。</li></ul><h3 id="_1-2-求解器初始化" tabindex="-1"><a class="header-anchor" href="#_1-2-求解器初始化"><span>1.2 求解器初始化</span></a></h3><p>在 <code>scenario.py</code> 的 <code>setup(self)</code> 函数中，系统加载 <code>robot_descriptor.yaml</code> 和 <code>urdf</code> 文件，并实例化两个核心生成器：</p><ul><li><strong><code>LulaCSpaceTrajectoryGenerator</code></strong>：处理关节空间（角度）路径。</li><li><strong><code>LulaTaskSpaceTrajectoryGenerator</code></strong>：处理任务空间（位姿）路径。</li></ul><h3 id="_1-3-核心组件功能表" tabindex="-1"><a class="header-anchor" href="#_1-3-核心组件功能表"><span>1.3 核心组件功能表</span></a></h3><table><thead><tr><th style="text-align:left;">类名</th><th style="text-align:left;">所属文件</th><th style="text-align:left;">功能描述</th></tr></thead><tbody><tr><td style="text-align:left;"><code>LulaCSpaceTrajectoryGenerator</code></td><td style="text-align:left;"><a href="http://scenario.py" target="_blank" rel="noopener noreferrer">scenario.py</a></td><td style="text-align:left;">基于样条插值连接关节空间点。</td></tr><tr><td style="text-align:left;"><code>LulaTaskSpaceTrajectoryGenerator</code></td><td style="text-align:left;"><a href="http://scenario.py" target="_blank" rel="noopener noreferrer">scenario.py</a></td><td style="text-align:left;">在 3D 空间内规划末端执行器的几何路径。</td></tr><tr><td style="text-align:left;"><code>ArticulationTrajectory</code></td><td style="text-align:left;"><a href="http://scenario.py" target="_blank" rel="noopener noreferrer">scenario.py</a></td><td style="text-align:left;"><strong>桥梁类</strong>。将连续轨迹映射到 60Hz 的物理帧动作序列。</td></tr></tbody></table><hr><h2 id="二、-c-space-关节空间-轨迹计算" tabindex="-1"><a class="header-anchor" href="#二、-c-space-关节空间-轨迹计算"><span>二、 C-Space (关节空间) 轨迹计算</span></a></h2><p>适用于已知目标姿态（所有轴的角度），并希望实现平滑过渡的场景。</p><h3 id="_2-1-时间最优轨迹生成" tabindex="-1"><a class="header-anchor" href="#_2-1-时间最优轨迹生成"><span>2.1 时间最优轨迹生成</span></a></h3><ul><li><strong>关键函数</strong>：<code>compute_c_space_trajectory(waypoints)</code></li><li><strong>作用</strong>：计算连接所有关节航点的最快路径。</li><li><strong>原理</strong>：它会使机器人至少在一个约束（速度、加速度或 Jerk）上达到物理极限（Saturate），从而实现效率最大化。</li></ul><h3 id="_2-2-定时轨迹生成" tabindex="-1"><a class="header-anchor" href="#_2-2-定时轨迹生成"><span>2.2 定时轨迹生成</span></a></h3><ul><li><strong>关键函数</strong>：<code>compute_timestamped_c_space_trajectory(waypoints, timestamps)</code></li><li><strong>作用</strong>：在特定的时刻到达特定的角度。</li><li><strong>应用场景</strong>：例如设定 <code>timestamps = [0, 5, 10]</code>，机器人会精准地在第 5 秒到达第二个航点。</li></ul><h3 id="_2-3-轨迹离散化逻辑" tabindex="-1"><a class="header-anchor" href="#_2-3-轨迹离散化逻辑"><span>2.3 轨迹离散化逻辑</span></a></h3><p>轨迹生成器返回的是连续函数。通过以下步骤，我们获得一个包含每一帧（1/60s）动作指令的列表：</p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">articulation_trajectory </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> ArticulationTrajectory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">self</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">._articulation, trajectory, physics_dt)</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 获取 60Hz 的动作序列</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">action_sequence </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> articulation_trajectory.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get_action_sequence</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',22)])])}]]),n=JSON.parse('{"path":"/posts/002_Study_Notes/01_Isaacsim4.5/%E8%BF%90%E5%8A%A8/4_Lula%20Trajectory%20Generator.html","title":"Lula Trajectory Generator 架构深度学习笔记","lang":"zh-CN","frontmatter":{"title":"Lula Trajectory Generator 架构深度学习笔记","shortTitle":"Lula Trajectory Generator","order":4,"description":"Lula Trajectory Generator 架构深度学习笔记 学习背景：深入理解 NVIDIA Isaac Sim 中 Lula 轨迹生成系统。该系统通过连接离散的航点，生成平滑、符合动力学约束（速度、加速度、Jerk）的运动指令。 一、 架构总览与初始化逻辑 1.1 核心分工 Lula 轨迹生成系统由两个主要脚本驱动，职责明确： scenar...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Lula Trajectory Generator 架构深度学习笔记\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-01-03T08:18:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Vita\\",\\"url\\":\\"https://vitasays.github.io/hi-hub/\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/hi-hub/posts/002_Study_Notes/01_Isaacsim4.5/%E8%BF%90%E5%8A%A8/4_Lula%20Trajectory%20Generator.html"}],["meta",{"property":"og:site_name","content":"VitaLab"}],["meta",{"property":"og:title","content":"Lula Trajectory Generator 架构深度学习笔记"}],["meta",{"property":"og:description","content":"Lula Trajectory Generator 架构深度学习笔记 学习背景：深入理解 NVIDIA Isaac Sim 中 Lula 轨迹生成系统。该系统通过连接离散的航点，生成平滑、符合动力学约束（速度、加速度、Jerk）的运动指令。 一、 架构总览与初始化逻辑 1.1 核心分工 Lula 轨迹生成系统由两个主要脚本驱动，职责明确： scenar..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-03T08:18:35.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-03T08:18:35.000Z"}]]},"git":{"createdTime":1767428315000,"updatedTime":1767428315000,"contributors":[{"name":"VitaSays","username":"VitaSays","email":"wxiao7100@gmail.com","commits":1,"url":"https://github.com/VitaSays"}]},"readingTime":{"minutes":1.82,"words":547},"filePathRelative":"posts/002_Study_Notes/01_Isaacsim4.5/运动/4_Lula Trajectory Generator.md","excerpt":"\\n<blockquote>\\n<p><strong>学习背景</strong>：深入理解 NVIDIA Isaac Sim 中 Lula 轨迹生成系统。该系统通过连接离散的航点，生成平滑、符合动力学约束（速度、加速度、Jerk）的运动指令。</p>\\n</blockquote>\\n<hr>\\n<h2>一、 架构总览与初始化逻辑</h2>\\n<h3>1.1 核心分工</h3>\\n<p>Lula 轨迹生成系统由两个主要脚本驱动，职责明确：</p>\\n<ul>\\n<li><strong><code>scenario.py</code> (算法逻辑层)</strong>：负责加载机器人配置、调用 Lula 库计算数学轨迹、将轨迹离散化为动作序列。</li>\\n<li><strong><code>ui_builder.py</code> (交互表现层)</strong>：负责渲染 Isaac Sim 右侧面板的按钮，控制仿真时间线的播放与暂停。</li>\\n</ul>","autoDesc":true}')}}]);